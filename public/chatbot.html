<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gemini Chatbot</title>
  <style>
    :root {
      --bg: #f5f7fa;
      --text: #1a202c;
      --card: #ffffff;
      --highlight: #3b82f6;
      --bot-bg: #e5e7eb;
      --error-bg: #ef4444;
      --button-bg: #3b82f6;
      --button-hover: #2563eb;
    }
    body.dark {
      --bg: #111827;
      --text: #e5e7eb;
      --card: #1f2937;
      --bot-bg: #374151;
      --error-bg: #dc2626;
      --button-bg: #4b5563;
      --button-hover: #6b7280;
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 20px;
      margin: 0;
      transition: background 0.3s ease, color 0.3s ease;
    }
    #chatbox {
      max-width: 800px;
      margin: 20px auto;
      background: var(--card);
      border-radius: 12px;
      padding: 24px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }
    h2 {
      margin: 0 0 20px;
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--highlight);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .msg {
      margin-bottom: 16px;
      position: relative;
      display: flex;
      gap: 8px;
    }
    .user {
      font-weight: 600;
      color: var(--highlight);
    }
    .bot {
      background: var(--bot-bg);
      border-left: 4px solid var(--highlight);
      padding: 12px;
      border-radius: 8px;
      white-space: pre-wrap;
      overflow-x: auto;
      flex: 1;
      transition: background 0.3s ease;
    }
    .preview-img {
      max-width: 100%;
      max-height: 200px;
      margin-top: 10px;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--error-bg);
      color white;
      padding: 12px 24px;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      max-width: 300px;
      word-wrap: break-word;
      font-size: 0.9rem;
    }
    textarea, select, input[type="file"] {
      margin-top: 12px;
      padding: 12px;
      width: 100%;
      font-size: 1rem;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      background: #fff;
      transition: border-color 0.2s ease;
    }
    textarea:focus, select:focus, input[type="file"]:focus {
      outline: none;
      border-color: var(--highlight);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }
    button {
      padding: 12px;
      font-size: 1rem;
      border-radius: 8px;
      border: none;
      background: var(--button-bg);
      color: white;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    button:hover {
      background: var(--button-hover);
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
    }
    .copy-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 0.8rem;
      background: var(--highlight);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .copy-btn:hover {
      background: var(--button-hover);
    }
    @media (max-width: 600px) {
      body {
        padding: 12px;
      }
      #chatbox {
        padding: 16px;
      }
    }
  </style>
</head>
<body>
  <div id="chatbox">
    <h2>üí¨ Gemini Chatbot</h2>
    <div id="messages"></div>

    <textarea id="prompt" placeholder="Nh·∫≠p c√¢u h·ªèi c·ªßa b·∫°n... (Enter ƒë·ªÉ g·ª≠i, Shift+Enter ƒë·ªÉ xu·ªëng d√≤ng)"></textarea>
    <select id="model">
      <option value="gemini-2.0-flash">gemini-2.0-flash</option>
      <option value="gemini-2.0-pro">gemini-2.0-pro</option>
      <option value="gemini-1.5-pro">gemini-1.5-pro</option>
    </select>
    <input type="file" id="uploadInput" accept="image/png,image/jpeg,image/webp,.txt" />

    <div id="controls">
      <button onclick="sendMessage()">G·ª≠i</button>
      <button onclick="resetChat()">üîÑ Reset</button>
      <button onclick="toggleDarkMode()">üåì Dark Mode</button>
      <button onclick="exportChat()">üìÑ Xu·∫•t File</button>
    </div>
  </div>

  <script type="module">
    const messagesDiv = document.getElementById("messages");
    const promptInput = document.getElementById("prompt");
    const uploadInput = document.getElementById("uploadInput");
    const localKey = "chat_history";
    let history = [];
    let isSending = false;

    // Load saved chat history
    window.onload = () => {
      const saved = localStorage.getItem(localKey);
      if (saved) {
        const parsed = JSON.parse(saved);
        parsed.forEach(msg => {
          addMessage(msg.sender, formatMarkdown(msg.text), true);
        });
        history = parsed
          .filter(m => m.sender === "You" || m.sender === "Bot")
          .map(m => ({
            role: m.sender === "You" ? "user" : "model",
            parts: [{ text: m.text }],
          }));
      }
      if (localStorage.getItem("darkMode") === "true") {
        document.body.classList.add("dark");
      }
    };

    // Handle file upload (image or .txt)
    uploadInput.addEventListener("change", async () => {
      const file = uploadInput.files[0];
      if (file) {
        if (file.type.startsWith("image/")) {
          const img = document.createElement("img");
          img.src = URL.createObjectURL(file);
          img.className = "preview-img";
          messagesDiv.appendChild(img);
          window.scrollTo(0, document.body.scrollHeight);
        } else if (file.type === "text/plain") {
          const text = await file.text();
          promptInput.value += text;
        } else {
          showError("ƒê·ªãnh d·∫°ng file kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£. Ch·ªâ h·ªó tr·ª£ ·∫£nh (PNG, JPEG, WebP) ho·∫∑c file .txt.");
        }
        uploadInput.value = ""; // Reset file input
      }
    });

    // Debounced sendMessage
    async function sendMessage() {
      if (isSending) return;
      isSending = true;

      const prompt = promptInput.value.trim();
      const model = document.getElementById("model").value;
      const file = uploadInput.files[0];

      if (!prompt && !file) {
        showError("Vui l√≤ng nh·∫≠p c√¢u h·ªèi ho·∫∑c ch·ªçn file.");
        isSending = false;
        return;
      }

      addMessage("You", prompt || "[ƒê√£ g·ª≠i file]");
      promptInput.value = "";
      const thinking = addMessage("Bot", "<em>ƒêang suy nghƒ©...</em>", true);

      try {
        let body = { prompt, model, history };

        if (file && file.type.startsWith("image/")) {
          const reader = new FileReader();
          reader.onload = async () => {
            const base64 = reader.result.split(",")[1];
            const mimeType = file.type;

            try {
              const res = await fetch("/api/gemini", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ ...body, image: { data: base64, mimeType } }),
              });
              const data = await res.json();

              if (!res.ok || data.error) {
                throw new Error(data.error?.message || `L·ªói kh√¥ng x√°c ƒë·ªãnh (${data.code || "UNKNOWN"})`);
              }

              const reply = data.reply || "Kh√¥ng c√≥ ph·∫£n h·ªìi.";
              updateMessage(thinking, formatMarkdown(reply));
              history = data.history || [...history, { role: "user", parts: [{ text: prompt }] }, { role: "model", parts: [{ text: reply }] }];
              saveToLocal();
              uploadInput.value = "";
            } catch (err) {
              showError(`L·ªói: ${err.message}`);
              updateMessage(thinking, "‚ùå L·ªói khi g·ªçi API.");
            } finally {
              isSending = false;
            }
          };
          reader.readAsDataURL(file);
        } else {
          const res = await fetch("/api/gemini", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });
          const data = await res.json();

          if (!res.ok || data.error) {
            throw new Error(data.error?.message || `L·ªói kh√¥ng x√°c ƒë·ªãnh (${data.code || "UNKNOWN"})`);
          }

          const reply = data.reply || "Kh√¥ng c√≥ ph·∫£n h·ªìi.";
          updateMessage(thinking, formatMarkdown(reply));
          history = data.history || [...history, { role: "user", parts: [{ text: prompt }] }, { role: "model", parts: [{ text: reply }] }];
          saveToLocal();
        }
      } catch (err) {
        showError(`L·ªói: ${err.message}`);
        updateMessage(thinking, "‚ùå L·ªói khi g·ªçi API.");
      } finally {
        isSending = false;
      }
    }

    function addMessage(sender, text, isHTML = false) {
      const msgDiv = document.createElement("div");
      msgDiv.className = "msg";

      const avatar = document.createElement("span");
      avatar.style.fontSize = "1.5em";
      avatar.style.marginRight = "8px";
      avatar.textContent = sender === "You" ? "üßë" : "ü§ñ";

      const senderSpan = document.createElement("div");
      senderSpan.className = "user";
      senderSpan.textContent = `${sender}:`;

      const contentDiv = document.createElement("div");
      contentDiv.className = "bot";
      contentDiv.innerHTML = isHTML ? text : escapeHTML(text);

      if (sender === "Bot") {
        const copyBtn = document.createElement("button");
        copyBtn.className = "copy-btn";
        copyBtn.textContent = "üìã Copy";
        copyBtn.onclick = () => {
          navigator.clipboard.writeText(contentDiv.textContent);
          copyBtn.textContent = "‚úÖ Copied!";
          setTimeout(() => (copyBtn.textContent = "üìã Copy"), 1500);
        };
        msgDiv.appendChild(copyBtn);
      }

      msgDiv.appendChild(avatar);
      msgDiv.appendChild(senderSpan);
      msgDiv.appendChild(contentDiv);
      messagesDiv.appendChild(msgDiv);

      window.scrollTo(0, document.body.scrollHeight);
      return contentDiv;
    }

    function updateMessage(node, newText) {
      node.innerHTML = newText;
      window.scrollTo(0, document.body.scrollHeight);
    }

    function showError(message) {
      const toast = document.createElement("div");
      toast.className = "toast";
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 5000);
    }

    function resetChat() {
      messagesDiv.innerHTML = "";
      history = [];
      localStorage.removeItem(localKey);
    }

    function toggleDarkMode() {
      document.body.classList.toggle("dark");
      localStorage.setItem("darkMode", document.body.classList.contains("dark"));
    }

    function formatMarkdown(text) {
      return text
        .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
        .replace(/\*(.*?)\*/g, "<em>$1</em>")
        .replace(/`([^`]+)`/g, "<code>$1</code>")
        .replace(/\n/g, "<br>");
    }

    function escapeHTML(str) {
      return str.replace(/[&<>'"]/g, tag => ({
        '&': '&', '<': '<', '>': '>',
        "'": ''', '"': '"',
      }[tag]));
    }

    function saveToLocal() {
      const saved = history.slice(-100).map(h => ({
        sender: h.role === "user" ? "You" : "Bot",
        text: h.parts[0].text
      }));
      localStorage.setItem(localKey, JSON.stringify(saved));
    }

    function exportChat() {
      const saved = localStorage.getItem(localKey);
      if (!saved) return showError("Kh√¥ng c√≥ h·ªôi tho·∫°i ƒë·ªÉ xu·∫•t.");
      const messages = JSON.parse(saved);
      const lines = messages.map(m => `${m.sender}: ${m.text}`).join("\n\n");
      const blob = new Blob([lines], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "chat_history.txt";
      a.click();
      URL.revokeObjectURL(url);
    }

    // Debounce keydown event
    promptInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // Export functions globally
    window.sendMessage = sendMessage;
    window.resetChat = resetChat;
    window.toggleDarkMode = toggleDarkMode;
    window.exportChat = exportChat;
  </script>
</body>
</html>
