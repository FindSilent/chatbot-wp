<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gemini Chatbot</title>
  <style>
    :root {
      --bg: #f2f2f2;
      --text: #222;
      --card: #fff;
      --highlight: #1a73e8;
      --bot-bg: #f9f9f9;
    }
    body.dark {
      --bg: #121212;
      --text: #e0e0e0;
      --card: #1e1e1e;
      --bot-bg: #2a2a2a;
    }
    body {
      font-family: Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 40px;
      transition: 0.3s;
    }
    #chatbox {
      max-width: 700px;
      margin: auto;
      background: var(--card);
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    .msg {
      margin-bottom: 20px;
    }
    .user {
      font-weight: bold;
      color: var(--highlight);
    }
    .bot {
      background-color: var(--bot-bg);
      border-left: 4px solid var(--highlight);
      padding: 10px;
      border-radius: 5px;
      white-space: pre-wrap;
      overflow-x: auto;
    }
    textarea, button, select {
      margin-top: 10px;
      padding: 10px;
      width: 100%;
      font-size: 1rem;
      border-radius: 5px;
      border: 1px solid #ccc;
    }
    button {
      cursor: pointer;
      margin-top: 10px;
    }
    #controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    code {
      background: #eee;
      padding: 2px 4px;
      border-radius: 4px;
      font-family: monospace;
    }
    pre {
      background: #eee;
      padding: 10px;
      border-radius: 6px;
      overflow-x: auto;
    }
    a {
      color: var(--highlight);
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="chatbox">
    <h2>üí¨ Gemini Chatbot</h2>
    <div id="messages"></div>

    <textarea id="prompt" rows="3" placeholder="Nh·∫≠p c√¢u h·ªèi c·ªßa b·∫°n... (Enter ƒë·ªÉ g·ª≠i, Shift+Enter ƒë·ªÉ xu·ªëng d√≤ng)"></textarea>
    <input type="file" id="fileInput" accept=".png,.jpg,.jpeg,.txt,.pdf" />
    <select id="model">
      <option value="gemini-2.0-flash">gemini-2.0-flash</option>
      <option value="gemini-2.0-pro">gemini-2.0-pro</option>
      <option value="gemini-1.5-pro">gemini-1.5-pro</option>
    </select>

    <div id="controls">
      <button onclick="sendMessage()">G·ª≠i</button>
      <button onclick="resetChat()">üîÑ Reset</button>
      <button onclick="toggleDarkMode()">üåì Dark Mode</button>
      <button onclick="exportChat()">üìÑ Xu·∫•t File</button>
    </div>
  </div>

  <script>
    const messagesDiv = document.getElementById("messages");
    const promptInput = document.getElementById("prompt");
    const localKey = "chat_history";
    let history = [];

    window.onload = () => {
      const saved = localStorage.getItem(localKey);
      if (saved) {
        const parsed = JSON.parse(saved);
        parsed.forEach(msg => {
          addMessage(msg.sender, formatMarkdown(msg.text), true);
        });
        history = parsed
          .filter(m => m.sender === "You" || m.sender === "Bot")
          .map(m => ({
            role: m.sender === "You" ? "user" : "model",
            parts: [{ text: m.text }],
          }));
      }

      if (localStorage.getItem("darkMode") === "true") {
        document.body.classList.add("dark");
      }
    };

    promptInput.addEventListener("keydown", e => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    async function sendMessage() {
      const prompt = promptInput.value.trim();
      const model = document.getElementById("model").value;
      if (!prompt) return;

      addMessage("You", prompt);
      promptInput.value = "";
      promptInput.focus();

      const thinking = addMessage("Bot", "<em>ü§î ƒêang suy nghƒ©...</em>", true);

      try {
        const res = await fetch("/api/gemini", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ prompt, model, history }),
        });

        const data = await res.json();

        if (!res.ok) throw new Error(data.error || "Unknown error");

        const reply = data.reply || "Kh√¥ng c√≥ ph·∫£n h·ªìi.";
        const formatted = formatMarkdown(reply);
        updateMessage(thinking, formatted);

        history.push({ role: "user", parts: [{ text: prompt }] });
        history.push({ role: "model", parts: [{ text: reply }] });

        saveToLocal();
      } catch (err) {
        console.error("Error:", err);
        updateMessage(thinking, `‚ùå L·ªói: ${err.message}`);
      }
    }

    function addMessage(sender, text, isHTML = false) {
      const msgDiv = document.createElement("div");
      msgDiv.className = "msg";

      const avatar = document.createElement("span");
      avatar.style.fontSize = "1.5em";
      avatar.style.marginRight = "8px";
      avatar.textContent = sender === "You" ? "üßë" : "ü§ñ";

      const senderSpan = document.createElement("div");
      senderSpan.className = "user";
      senderSpan.textContent = `${sender}:`;

      const contentDiv = document.createElement("div");
      contentDiv.className = "bot";
      contentDiv.innerHTML = isHTML ? text : escapeHTML(text);

      msgDiv.appendChild(avatar);
      msgDiv.appendChild(senderSpan);
      msgDiv.appendChild(contentDiv);
      messagesDiv.appendChild(msgDiv);

      window.scrollTo(0, document.body.scrollHeight);
      return contentDiv;
    }

    function updateMessage(node, newText) {
      node.innerHTML = newText;
      window.scrollTo(0, document.body.scrollHeight);
    }

    function resetChat() {
      if (confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô h·ªôi tho·∫°i?")) {
        messagesDiv.innerHTML = "";
        history = [];
        localStorage.removeItem(localKey);
      }
    }

    function toggleDarkMode() {
      document.body.classList.toggle("dark");
      localStorage.setItem("darkMode", document.body.classList.contains("dark"));
    }

    function formatMarkdown(text) {
      return text
        .replace(/^### (.*$)/gim, '<h3>$1</h3>')
        .replace(/^## (.*$)/gim, '<h2>$1</h2>')
        .replace(/^# (.*$)/gim, '<h1>$1</h1>')
        .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
        .replace(/\*(.*?)\*/g, "<em>$1</em>")
        .replace(/```([\s\S]*?)```/g, "<pre><code>$1</code></pre>")
        .replace(/`([^`]+)`/g, "<code>$1</code>")
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
        .replace(/\n/g, "<br>");
    }

    function escapeHTML(str) {
      return str.replace(/[&<>'"]/g, tag => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;',
        "'": '&#39;', '"': '&quot;',
      }[tag]));
    }

    function saveToLocal() {
      const saved = history.map(h => ({
        sender: h.role === "user" ? "You" : "Bot",
        text: h.parts[0].text
      }));
      localStorage.setItem(localKey, JSON.stringify(saved));
    }

    function exportChat() {
      const saved = localStorage.getItem(localKey);
      if (!saved) return alert("Kh√¥ng c√≥ h·ªôi tho·∫°i ƒë·ªÉ xu·∫•t.");
      const messages = JSON.parse(saved);
      const lines = messages.map(m => `${m.sender}: ${m.text}`).join("\n\n");

      const blob = new Blob([lines], { type: "text/plain" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "chat_history.txt";
      a.click();
      URL.revokeObjectURL(url);
    }
    document.getElementById("fileInput").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();

  reader.onload = async () => {
    let content = reader.result;

    if (file.type.startsWith("image/")) {
      content = `Ng∆∞·ªùi d√πng ƒë√£ g·ª≠i m·ªôt h√¨nh ·∫£nh: ${file.name} (kh√¥ng th·ªÉ hi·ªÉn th·ªã ·∫£nh trong chatbot text).`;
    }

    // G·ª≠i n·ªôi dung file nh∆∞ prompt
    promptInput.value = content;
    sendMessage();
  };

  if (file.type.startsWith("text/") || file.name.endsWith(".txt")) {
    reader.readAsText(file);
  } else if (file.type === "application/pdf") {
    const pdf = await file.arrayBuffer();
    const text = await extractTextFromPDF(pdf);
    promptInput.value = text.slice(0, 3000); // C·∫Øt b·ªõt n·∫øu qu√° d√†i
    sendMessage();
  } else {
    reader.readAsDataURL(file); // image fallback
  }
});

// PDF parser (d√πng pdf.js)
async function extractTextFromPDF(buffer) {
  const pdfjsLib = await import("https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.13.216/pdf.min.mjs");
  const pdf = await pdfjsLib.getDocument({ data: buffer }).promise;
  let text = "";
  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const content = await page.getTextContent();
    text += content.items.map(item => item.str).join(" ") + "\n";
  }
  return text;
}

  </script>
</body>
</html>
